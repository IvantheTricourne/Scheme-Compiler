(library (Compiler normalize-context)
  (export normalize-context)
  (import (chezscheme) (Framework match) (Framework helpers) (Compiler helpers))
  (define-who (normalize-context x)
    (define (Exp x)
      (match x
        ((let ([,var ,[exp*]] ...) ,[exp]) `(let ([,var ,exp*] ...) ,exp))
        ((begin ,[Effect -> eff*] ... ,[exp])
         (make-nopless-begin `(,@eff* ,exp)))
        ((if ,[Pred -> p] ,[cexp] ,[aexp]) `(if ,p ,cexp ,aexp))
        ((quote ,val) (guard (imm? val)) `(quote ,val))
        (,var (guard (or (label? var) (uvar? var))) var)
        ((void) `(void))
        ;; rator/rands
        ((,op ,[arg] ,[arg*] ...) (guard (pred-prim? op))
         `(if (,op ,arg ,@arg*) '#t '#f))
	((,op ,[arg] ,[arg*] ...) (guard (val-prim? op))
         `(,op ,arg ,@arg*))
	((,op ,[arg] ,[arg*] ...) (guard (eff-prim? op))
         (make-nopless-begin `((,op ,arg ,@arg*) (void))))
        ;; Thunks and proc calls
        ((,[op] ,[arg*] ...) `(,op ,@arg*))))
    (define (Pred x)
      (define (make-if-exp exp) `(if (eq? ,exp '#f) (false) (true)))
      (match x
        ((let ([,var ,[Exp -> exp]] ...) ,[pred])
         `(let ([,var ,exp] ...) ,pred))
        ((begin ,[Effect -> eff*] ... ,[pred])
         (make-nopless-begin `(,@eff* ,pred)))
        ((if ,[p] ,[cpred] ,[apred]) `(if ,p ,cpred ,apred))
        ((quote ,val) (guard (imm? val)) (if val '(true) '(false)))
        ((void) (make-if-exp `(void)))
        (,var (guard (or (label? var) (uvar? var))) (make-if-exp var))
        ;; rator/rand
        ((,op ,[Exp -> arg] ,[Exp -> arg*] ...) (guard (pred-prim? op))
         `(,op ,arg ,@arg*))
        ((,op ,[Exp -> arg] ,[Exp -> arg*] ...) (guard (val-prim? op))
         (make-if-exp `(,op ,arg ,@arg*)))
        ((,op ,[Exp -> arg] ,[Exp -> arg*] ...) (guard (eff-prim? op))
         (make-nopless-begin `((,op ,arg ,@arg*) (true))))
        ;; Thunks and proc calls
        ((,[op] ,[arg*] ...) (make-if-exp `(,op ,@arg*)))))
    (define (Effect x)
      (match x
        ((let ([,var ,[Exp -> exp]] ...) ,[eff]) `(let ([,var ,exp] ...) ,eff))
        ((begin ,[eff*] ... ,[eff]) (make-nopless-begin `(,@eff* ,eff)))
        ((if ,[Pred -> p] ,[ceff] ,[aeff]) `(if ,p ,ceff ,aeff))
        ((quote ,val) (guard (imm? val)) `(nop))
        ((void) `(nop))
	(,var (guard (or (label? var) (uvar? var))) `(nop))
        ;; rator/rands
        ((,op ,[arg] ,[arg*] ...) (guard (pred-prim? op))
         (make-nopless-begin `(,arg ,@arg*)))
        ((,op ,[Exp -> arg] ,[Exp -> arg*] ...) (guard (eff-prim? op))
         `(,op ,arg ,@arg*))
        ((,op ,[arg] ,[arg*] ...) (guard (val-prim? op))
         (make-nopless-begin `(,arg ,@arg*)))
        ;; Thunks and proc calls
        ((,[op] ,[arg*] ...) (make-nopless-begin `(,op ,@arg*)))))
    (define (make-nopless-begin x*)
      (let ([x* (remove '(nop) x*)])
        (if (null? x*) '(nop) (make-begin x*))))
    (match x
      ((letrec ([,l* (lambda ,args* ,[Exp -> exp*])] ...) ,[Exp -> exp])
       `(letrec ([,l* (lambda ,args* ,exp*)] ...) ,exp)))))
