(library (Compiler finalize-frame-locations)
  (export finalize-frame-locations)
  (import (chezscheme) (Framework helpers) (Framework match))
  (define-who (finalize-frame-locations x)
    (define (Var env)
      (lambda (v)
        (cond
         ((and (uvar? v) (assq v env)) => cdr)
         (else v))))
    (define Triv Var)
    (define (Body b)
      (match b
        ((locals (,uvar* ...)
           (ulocals (,uuvar* ...)
             (locate ((,uvar ,fvar) ...)
               (frame-conflict ,ct ,[(Tail (map cons uvar fvar)) -> t]))))
         `(locals (,@uvar*)
            (ulocals (,@uuvar*)
              (locate ((,uvar ,fvar) ...)
                (frame-conflict ,ct ,t)))))
        ((locate ((,uvar ,fvar) ...) ,[(Tail (map cons uvar fvar)) -> t]) `(locate ((,uvar ,fvar) ...) ,t))))
    (define (Tail env)
      (lambda (tail)
        (match tail
          ((begin ,[(Effect env) -> ef*] ... ,[tail]) `(begin ,@ef* ,tail))
          ((if ,[(Pred env) -> pred] ,[c] ,[a]) `(if ,pred ,c ,a))
          ((,[(Triv env) -> t] ,[(Triv env) -> loc*] ...) `(,t ,@loc*)))))
    (define (Pred env)
      (lambda (pr)
        (match pr
          ((true) '(true))
          ((false) '(false))
          ((if ,[pred] ,[c] ,[a]) `(if ,pred ,c ,a))
          ((begin ,[(Effect env) -> ef*] ... ,[pred]) `(begin ,@ef* ,pred))
          ((,relop ,[(Triv env) -> x] ,[(Triv env) -> y]) `(,relop ,x ,y)))))
    (define (Effect env)
      (lambda (ef)
        (match ef
          ((nop) '(nop))
          ((set! ,[(Var env) -> x] (,binop ,[(Triv env) -> y] ,[(Triv env) -> z])) `(set! ,x (,binop ,y ,z)))
          ((set! ,[(Var env) -> x] ,[(Triv env) -> y]) (if (eq? x y) '(nop) `(set! ,x ,y)))
          ((mset! ,[(Triv env) -> x] ,[(Triv env) -> y] ,[(Triv env) -> z]) `(mset! ,x ,y ,z))
          ((begin ,[ef] ,[ef*] ...) `(begin ,ef ,@ef*))
          ((if ,[(Pred env) -> pred] ,[c] ,[a]) `(if ,pred ,c ,a))
          ((return-point ,lab ,[(Tail env) -> tail]) `(return-point ,lab ,tail)))))
    (match x
      ((letrec ((,label* (lambda () ,[Body -> body*])) ...) ,[Body -> body])
       `(letrec ([,label* (lambda () ,body*)] ...) ,body)))))
